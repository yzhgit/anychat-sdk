/**
 * AnyChatClient.ts - Main client class with Promise-based API
 */

import { EventEmitter } from './EventEmitter';
import {
  ClientConfig,
  AuthToken,
  Message,
  Conversation,
  Friend,
  FriendRequest,
  Group,
  GroupMember,
  ConnectionState,
  ConnectionStateListener,
  MessageReceivedListener,
  ConversationUpdatedListener,
  FriendRequestListener,
  FriendListChangedListener,
  GroupInvitedListener,
  GroupUpdatedListener,
  AuthExpiredListener,
  AnyChatError,
} from './types';

// Events emitted by the client
export interface ClientEvents {
  connectionStateChanged: ConnectionState;
  messageReceived: Message;
  conversationUpdated: Conversation;
  friendRequest: FriendRequest;
  friendListChanged: void;
  groupInvited: { group: Group; inviterId: string };
  groupUpdated: Group;
  authExpired: void;
}

// WASM module interface (generated by Emscripten)
interface WasmModule {
  AnyChatClientWrapper: new (config: any) => AnyChatClientWrapperInstance;
}

interface AnyChatClientWrapperInstance {
  connect(): void;
  disconnect(): void;
  getConnectionState(): number;
  setConnectionCallback(callback: (state: number) => void): void;
  login(account: string, password: string, deviceType: string, callback: (error: string | null, token: any) => void): void;
  register(phoneOrEmail: string, password: string, verifyCode: string, deviceType: string, nickname: string, callback: (error: string | null, token: any) => void): void;
  logout(callback: (error: string | null) => void): void;
  refreshToken(refreshToken: string, callback: (error: string | null, token: any) => void): void;
  isLoggedIn(): boolean;
  setAuthExpiredCallback(callback: () => void): void;
  sendTextMessage(sessionId: string, content: string, callback: (error: string | null) => void): void;
  getMessageHistory(sessionId: string, beforeTimestamp: number, limit: number, callback: (error: string | null, messages: any[]) => void): void;
  markMessageRead(sessionId: string, messageId: string, callback: (error: string | null) => void): void;
  setMessageReceivedCallback(callback: (message: any) => void): void;
  getConversationList(callback: (error: string | null, conversations: any[]) => void): void;
  markConversationRead(convId: string, callback: (error: string | null) => void): void;
  setConversationPinned(convId: string, pinned: boolean, callback: (error: string | null) => void): void;
  setConversationMuted(convId: string, muted: boolean, callback: (error: string | null) => void): void;
  deleteConversation(convId: string, callback: (error: string | null) => void): void;
  setConversationUpdatedCallback(callback: (conversation: any) => void): void;
  getFriendList(callback: (error: string | null, friends: any[]) => void): void;
  sendFriendRequest(toUserId: string, message: string, callback: (error: string | null) => void): void;
  handleFriendRequest(requestId: number, accept: boolean, callback: (error: string | null) => void): void;
  getPendingFriendRequests(callback: (error: string | null, requests: any[]) => void): void;
  deleteFriend(friendId: string, callback: (error: string | null) => void): void;
  setFriendRequestCallback(callback: (request: any) => void): void;
  setFriendListChangedCallback(callback: () => void): void;
  getGroupList(callback: (error: string | null, groups: any[]) => void): void;
  createGroup(name: string, memberIds: string[], callback: (error: string | null) => void): void;
  joinGroup(groupId: string, message: string, callback: (error: string | null) => void): void;
  inviteToGroup(groupId: string, userIds: string[], callback: (error: string | null) => void): void;
  quitGroup(groupId: string, callback: (error: string | null) => void): void;
  getGroupMembers(groupId: string, page: number, pageSize: number, callback: (error: string | null, members: any[]) => void): void;
  setGroupInvitedCallback(callback: (group: any, inviterId: string) => void): void;
  setGroupUpdatedCallback(callback: (group: any) => void): void;
}

export class AnyChatClient extends EventEmitter<ClientEvents> {
  private wasmInstance: AnyChatClientWrapperInstance | null = null;
  private config: ClientConfig;

  constructor(config: ClientConfig) {
    super();
    this.config = config;
  }

  /**
   * Initialize the WASM module and create the client instance.
   * Must be called before any other operations.
   */
  async initialize(wasmModule: WasmModule): Promise<void> {
    try {
      this.wasmInstance = new wasmModule.AnyChatClientWrapper(this.config);
      this.setupCallbacks();
    } catch (error) {
      throw new AnyChatError(`Failed to initialize client: ${error}`);
    }
  }

  private ensureInitialized(): AnyChatClientWrapperInstance {
    if (!this.wasmInstance) {
      throw new AnyChatError('Client not initialized. Call initialize() first.');
    }
    return this.wasmInstance;
  }

  private setupCallbacks(): void {
    const instance = this.ensureInitialized();

    instance.setConnectionCallback((state: number) => {
      this.emit('connectionStateChanged', state as ConnectionState);
    });

    instance.setMessageReceivedCallback((message: any) => {
      this.emit('messageReceived', message as Message);
    });

    instance.setConversationUpdatedCallback((conversation: any) => {
      this.emit('conversationUpdated', conversation as Conversation);
    });

    instance.setFriendRequestCallback((request: any) => {
      this.emit('friendRequest', request as FriendRequest);
    });

    instance.setFriendListChangedCallback(() => {
      this.emit('friendListChanged', undefined);
    });

    instance.setGroupInvitedCallback((group: any, inviterId: string) => {
      this.emit('groupInvited', { group: group as Group, inviterId });
    });

    instance.setGroupUpdatedCallback((group: any) => {
      this.emit('groupUpdated', group as Group);
    });

    instance.setAuthExpiredCallback(() => {
      this.emit('authExpired', undefined);
    });
  }

  // ===== Connection Management =====

  connect(): void {
    this.ensureInitialized().connect();
  }

  disconnect(): void {
    this.ensureInitialized().disconnect();
  }

  getConnectionState(): ConnectionState {
    return this.ensureInitialized().getConnectionState() as ConnectionState;
  }

  // ===== Authentication =====

  login(account: string, password: string, deviceType: string = 'web'): Promise<AuthToken> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.login(account, password, deviceType, (error, token) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(token as AuthToken);
        }
      });
    });
  }

  register(
    phoneOrEmail: string,
    password: string,
    verifyCode: string,
    deviceType: string = 'web',
    nickname: string = ''
  ): Promise<AuthToken> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.register(phoneOrEmail, password, verifyCode, deviceType, nickname, (error, token) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(token as AuthToken);
        }
      });
    });
  }

  logout(): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.logout((error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  refreshToken(refreshToken: string): Promise<AuthToken> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.refreshToken(refreshToken, (error, token) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(token as AuthToken);
        }
      });
    });
  }

  isLoggedIn(): boolean {
    return this.ensureInitialized().isLoggedIn();
  }

  // ===== Message Operations =====

  sendTextMessage(sessionId: string, content: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.sendTextMessage(sessionId, content, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  getMessageHistory(sessionId: string, beforeTimestamp: number = 0, limit: number = 20): Promise<Message[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getMessageHistory(sessionId, beforeTimestamp, limit, (error, messages) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(messages as Message[]);
        }
      });
    });
  }

  markMessageRead(sessionId: string, messageId: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.markMessageRead(sessionId, messageId, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  // ===== Conversation Operations =====

  getConversationList(): Promise<Conversation[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getConversationList((error, conversations) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(conversations as Conversation[]);
        }
      });
    });
  }

  markConversationRead(convId: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.markConversationRead(convId, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  setConversationPinned(convId: string, pinned: boolean): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.setConversationPinned(convId, pinned, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  setConversationMuted(convId: string, muted: boolean): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.setConversationMuted(convId, muted, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  deleteConversation(convId: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.deleteConversation(convId, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  // ===== Friend Operations =====

  getFriendList(): Promise<Friend[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getFriendList((error, friends) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(friends as Friend[]);
        }
      });
    });
  }

  sendFriendRequest(toUserId: string, message: string = ''): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.sendFriendRequest(toUserId, message, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  handleFriendRequest(requestId: number, accept: boolean): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.handleFriendRequest(requestId, accept, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  getPendingFriendRequests(): Promise<FriendRequest[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getPendingFriendRequests((error, requests) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(requests as FriendRequest[]);
        }
      });
    });
  }

  deleteFriend(friendId: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.deleteFriend(friendId, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  // ===== Group Operations =====

  getGroupList(): Promise<Group[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getGroupList((error, groups) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(groups as Group[]);
        }
      });
    });
  }

  createGroup(name: string, memberIds: string[]): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.createGroup(name, memberIds, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  joinGroup(groupId: string, message: string = ''): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.joinGroup(groupId, message, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  inviteToGroup(groupId: string, userIds: string[]): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.inviteToGroup(groupId, userIds, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  quitGroup(groupId: string): Promise<void> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.quitGroup(groupId, (error) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve();
        }
      });
    });
  }

  getGroupMembers(groupId: string, page: number = 1, pageSize: number = 20): Promise<GroupMember[]> {
    const instance = this.ensureInitialized();
    return new Promise((resolve, reject) => {
      instance.getGroupMembers(groupId, page, pageSize, (error, members) => {
        if (error) {
          reject(new AnyChatError(error));
        } else {
          resolve(members as GroupMember[]);
        }
      });
    });
  }
}
