# Flutter FFI Bindings Implementation Notes

## Overview

This Flutter package provides FFI (Foreign Function Interface) bindings to the AnyChat SDK's C API. The bindings are auto-generated using `ffigen` and wrapped with a high-level Dart API.

## Architecture Decisions

### Why FFI instead of SWIG?

1. **Dart Ecosystem**: `ffigen` is the official Dart tool for FFI binding generation
2. **Better Integration**: Generates code that works seamlessly with `dart:ffi`
3. **Platform Support**: Flutter FFI plugins work across all platforms (Android, iOS, Desktop)
4. **Performance**: Direct C calls with minimal overhead

### Why C API instead of C++ API?

The C API layer (`anychat_c`) solves critical ABI compatibility issues:

1. **Cross-Compiler**: MSVC, GCC, Clang binaries are incompatible at the C++ level
2. **Stable ABI**: C ABI is standardized and stable across compilers
3. **Simpler FFI**: C types map directly to Dart FFI types
4. **Industry Standard**: Used by SQLite, OpenSSL, FFmpeg, etc.

## Key Components

### 1. `ffigen.yaml` - Code Generation Config

Specifies which C headers to process and which types/functions to bind.

### 2. `lib/src/anychat_ffi_bindings.dart` - Auto-Generated Bindings

Generated by `dart run ffigen`. **Do not edit manually**.

Provides:
- Type definitions for all C structs
- Function signature bindings for all C functions
- Pointer types for opaque handles

### 3. `lib/src/native_loader.dart` - Library Loader

Loads the correct native library based on platform:
- Android: `libanychat_android.so`
- iOS: statically linked (DynamicLibrary.process())
- macOS: `libanychat_flutter_plugin.dylib`
- Linux: `libanychat_flutter_plugin.so`
- Windows: `anychat_flutter_plugin.dll`

### 4. `lib/src/models.dart` - Dart Data Models

Pure Dart classes that represent SDK entities (Message, Conversation, etc.).
These are converted to/from C structs when calling FFI functions.

### 5. `lib/src/anychat_client.dart` - High-Level API

Wraps the low-level FFI bindings with a Dart-friendly API:
- Converts C callbacks → Dart `Future<T>`
- Converts C structs → Dart classes
- Manages memory (allocates/frees C strings and structs)
- Provides reactive `Stream<T>` for events

## Memory Management Rules

### String Inputs (Dart → C)

```dart
// Dart string
final str = 'hello';

// Convert to C string (allocates memory)
final cStr = str.toNativeUtf8();

// Pass to C function
_bindings.some_function(cStr.cast());

// MUST free after use
calloc.free(cStr);
```

### String Outputs (C → Dart)

```dart
// C function returns a const char*
final cStrPtr = _bindings.some_function();

// Convert to Dart string (copies)
final str = cStrPtr.cast<Utf8>().toDartString();

// If C allocated the string, free it
if (needsFreeing) {
  _bindings.anychat_free_string(cStrPtr);
}
```

### Struct Outputs (C → Dart)

```dart
// Allocate C struct on the heap
final tokenStruct = calloc<AnyChatAuthToken_C>();

// Pass to C function (C fills the struct)
final ret = _bindings.anychat_auth_get_current_token(_auth, tokenStruct);

if (ret == 0) {
  // Read fields from C struct
  final token = AuthToken(
    accessToken: _copyFixedString(tokenStruct.ref.access_token, 512),
    refreshToken: _copyFixedString(tokenStruct.ref.refresh_token, 512),
    expiresAtMs: tokenStruct.ref.expires_at_ms,
  );
}

// MUST free after use
calloc.free(tokenStruct);
```

### List Outputs (C → Dart)

C functions that return lists use a callback pattern:

```c
typedef void (*Callback)(void* userdata, const List_C* list, const char* error);

int some_function(Handle h, void* userdata, Callback cb);
```

The Dart wrapper:
1. Creates a `Completer<List<T>>`
2. Passes a C function pointer (via `NativeCallable`) as the callback
3. In the C callback:
   - Converts `List_C` → `List<T>`
   - Completes the Dart `Future`
   - C SDK frees the list after the callback returns
4. Returns `Future<List<T>>` to the caller

## Callbacks: C → Dart

C callbacks use function pointers:

```c
typedef void (*Callback)(void* userdata, int arg);
```

Dart FFI requires `NativeCallable` (Dart 2.18+) to convert Dart closures → C function pointers:

```dart
import 'dart:ffi';

// Define the C callback signature
typedef NativeCallback = Void Function(Pointer<Void> userdata, Int arg);
typedef DartCallback = void Function(Pointer<Void> userdata, int arg);

void dartCallback(Pointer<Void> userdata, int arg) {
  print('Called from C with arg: $arg');
}

// Create a C function pointer from the Dart function
final nativeCallback = NativeCallable<NativeCallback>.listener(dartCallback);

// Pass to C
_bindings.set_callback(nativeCallback.nativeFunction);

// IMPORTANT: Keep nativeCallback alive as long as C might call it
// Close when done:
// nativeCallback.close();
```

**Current Limitation**: The placeholder implementation uses `UnimplementedError` because full callback support requires careful lifecycle management and Dart 2.18+.

## Platform-Specific Build

### Android

`android/CMakeLists.txt` references the SDK root and builds:
1. `anychat_core` (C++ library)
2. `anychat_c` (C wrapper)
3. `anychat_android` (shared library)

The shared library is copied to `jniLibs/` during the Flutter build.

### iOS / macOS

`.podspec` files use a `prepare_command` to:
1. Run CMake with the iOS/macOS toolchain
2. Build `anychat_c.a` and `anychat_core.a`
3. Copy static libraries to the plugin directory
4. Link via `vendored_libraries`

### Linux / Windows

`CMakeLists.txt` files similar to Android, but output to the Flutter build directory.

## Testing Strategy

1. **Unit Tests**: Test Dart models and utility functions (no FFI)
2. **Integration Tests**: Run on-device tests that call C functions
3. **Memory Leak Tests**: Use `valgrind` (Linux) or Instruments (macOS/iOS) to detect leaks

## Future Improvements

1. **Complete Callback Implementation**: Use `NativeCallable` for all async operations
2. **Error Handling**: Wrap all FFI calls in try-catch and convert C errors to Dart exceptions
3. **Finalizers**: Use `NativeFinalizer` (Dart 2.17+) for automatic cleanup of handles
4. **Isolate Support**: Ensure thread safety for multi-isolate usage
5. **Reduce Boilerplate**: Generate more of the Dart wrapper via code generation

## References

- [Dart FFI Documentation](https://dart.dev/guides/libraries/c-interop)
- [ffigen Package](https://pub.dev/packages/ffigen)
- [Flutter FFI Plugin](https://docs.flutter.dev/development/platform-integration/android/c-interop)
- [NativeCallable](https://api.dart.dev/stable/dart-ffi/NativeCallable-class.html)
